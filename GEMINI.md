# AI 팀 빌딩 매니저 프로젝트: AI 에이전트 개발 지침 (GEMINI.md)

## 0. 이 문서의 목적과 활용법 (AI 필독)

이 `GEMINI.md` 문서는 'AI 팀 빌딩 매니저' 프로젝트의 **실행 지침서이자 진행 상황 추적기**입니다. 이 문서는 AI 에이전트인 당신의 핵심 운영 매뉴얼입니다.

**⚠️ 중요: 이 문서를 읽기 전, 반드시 `README_AI.md`를 먼저 정독하여 프로젝트의 전체적인 청사진(목표, 기술 스택, 아키텍처)을 완벽히 숙지해야 합니다.** `README_AI.md`는 프로젝트의 "왜(Why)"와 "무엇(What)"을, 이 `GEMINI.md`는 "어떻게(How)"와 "지금 어디(Where)"를 다룹니다.

**당신의 임무:**
1.  `Part 1`의 계획에 따라 프로젝트 개발을 주도적으로 실행합니다.
2.  `Part 2`의 지침에 따라 사용자와 상호작용하고, 프로젝트의 일관성을 유지합니다.
3.  `Part 3`을 통해 사장님의 역량 수준을 추적하고, 맞춤형 멘토링을 제공하여 풀스택 개발자로의 성장을 돕습니다.

---

## Part 1: 구현 단계별 계획 및 진행 상황

이 섹션은 프로젝트의 구현 계획을 상세히 설명하며, 각 항목의 진행 상태를 추적합니다. 완료된 작업은 `[x]`로 표시됩니다.

### Phase 0: 기반 공사 (Foundation & Setup)

-   [x] **환경 설정**: `devmatch-app` 디렉토리 내 `.env` 파일 생성 및 필수 환경 변수(DB, Auth, API 키) 설정 완료.
-   [x] **기존 의존성 및 빌드 파일 정리**: `node_modules` 디렉토리와 `pnpm-lock.yaml` 파일 삭제, `.next` 디렉토리 삭제를 통해 깨끗한 환경을 준비.
-   [x] **의존성 설치 및 검증**: `pnpm install`을 통해 모든 패키지 설치 완료 및 `package.json`에 명시된 의존성들이 올바르게 설치되었는지 확인.
-   [x] **UI 라이브러리 초기화 및 재설정**: `npx shadcn@latest init` 실행 및 `tailwind.config.ts`, `globals.css` 등 설정 재확인 및 필요시 재설정.
-   [x] **DB 연결 및 마이그레이션**: `pnpm prisma db push`를 실행하여 `prisma/schema.prisma`의 모델을 실제 데이터베이스에 동기화.
-   [x] **전역 레이아웃 설정**: `app/layout.tsx`에 기본 폰트, `ThemeProvider` (for 다크 모드), `Toaster` (for 알림 메시지) 등 전역 설정 적용.
-   [x] **공통 컴포넌트 생성**: `components/common/`에 `Header`, `Footer`, `LoadingSpinner` 등 여러 페이지에서 재사용될 기본 컴포넌트 생성.
-   [x] **TypeScript 설정 검증**: `tsconfig.json` 파일이 프로젝트 요구사항에 맞게 올바르게 설정되었는지 확인. (예: `paths` 설정, `compilerOptions` 등)

### Phase 1: 프로젝트의 시작 - "우리 팀의 깃발을 꽂다"

#### 1.1. 간편 로그인 (Google/Kakao OAuth)
-   [x] **DB**: 
    -   [x] `prisma/schema.prisma`에 `User`, `Account`, `Session` 모델 정의 완료.
    -   [x] `Account` 모델에 `refresh_token_expires_in` 필드를 추가하여 Kakao 로그인 오류 해결.
-   [x] **Backend**: `app/api/auth/[...nextauth]/route.ts` 파일 생성 및 NextAuth.js 기본 설정. Google, Kakao Provider 추가.
-   [x] **UI**: 
    -   [x] `app/auth/page.tsx` 생성 및 `Card` 컴포넌트 기반의 아이콘 버튼 UI로 개선 완료.
    -   [x] `app/page.tsx`에 랜딩 페이지 및 로그인 상태에 따른 자동 리다이렉트 로직 구현.
-   [x] **Flow**:
    -   [x] 루트 페이지(`/`) 접속 시, 로그인 상태를 확인하여 `/projects`로 자동 이동시키는 로직 구현.
    -   [x] 로그인 버튼 클릭 시 `signIn` 함수 호출.
    -   [x] 로그인 성공 후 세션 생성 확인.
    -   [x] 로그인 사용자를 `/projects` 페이지로 리다이렉트하는 로직 구현.
    -   [x] 로딩 및 에러 상태에 대한 시각적 피드백(스피너, 토스트 메시지) 처리.

#### 1.2. 프로젝트 초기 설정 (AI 상담 기반)
-   [x] **UI (페이지)**: `app/projects/new/page.tsx` 생성 및 Vercel AI SDK를 활용한 AI 대화형 상담 UI 구현.
-   [ ] **Backend**: `app/api/projects/initial-setup/route.ts` (가칭) AI 상담 결과 처리 및 임시 프로젝트 정보 저장 API 구현.
-   [ ] **Flow/Logic**:
    -   [ ] `[+ 새 프로젝트 시작하기]` 버튼 클릭 시 `/projects/new` 페이지로 이동.
    -   [ ] AI와 대화형으로 프로젝트 초기 정보(종류, 팀원 수, 기술 스택, 역할 분배) 상담.
    -   [ ] 상담 완료 후, 임시 프로젝트 정보 저장 및 프로젝트 '생성 중' 상태로 전환.
    -   [ ] 팀원 초대 페이지로 리다이렉트.

#### 1.3. 팀원 초대 및 개별 AI 인터뷰
-   [ ] **DB**: `prisma/schema.prisma`에 `InviteLink` 모델 정의 완료.
-   [ ] **UI**: 프로젝트 상세 페이지 내 `[팀원 초대하기]` 버튼과 링크 표시/복사 영역 UI 구현.
-   [ ] **Backend**: `app/api/projects/[projectId]/invite/route.ts`에 유효기간이 있는 고유 초대 링크 생성 API 구현.
-   [ ] **UI**: `app/projects/join/[inviteCode]/page.tsx` 초대 수락 페이지 UI 구현.
-   [ ] **Backend**: `inviteCode` 유효성 검증 및 사용자를 `ProjectMember`에 추가하는 로직 구현.
-   [ ] **UI**: `app/projects/[projectId]/interview/page.tsx`에 Vercel AI SDK를 활용한 대화형 채팅 UI 구현.
-   [ ] **Backend**: `app/api/ai/interview/route.ts` API 구현 (Gemini API와 연동).
-   [ ] **Flow/Logic**:
    -   [ ] 초대 링크로 접속 -> 로그인하지 않았다면 로그인 페이지로 이동 후 다시 복귀.
    -   [ ] 초대 정보 확인 후 `[참여하기]` 버튼 클릭.
    -   [ ] 참여 API 호출 성공 시, 해당 프로젝트의 AI 인터뷰 페이지로 이동.
    -   [ ] AI와 1:1 심층 인터뷰 진행 및 대화 내용 DB에 저장.

#### 1.4. 최종 프로젝트 확정 및 상세 페이지
-   [ ] **DB**: `prisma/schema.prisma`에 `RecommendedRole` 모델 정의 완료.
-   [ ] **UI**: 프로젝트 상세 페이지에 팀원별 추천 역할을 보여주는 대시보드 UI 구현.
-   [ ] **Backend**: `app/api/projects/[projectId]/recommend-roles` API(POST) 구현.
-   [ ] **Backend**: `app/api/projects/[projectId]/finalize/route.ts` (가칭) 최종 프로젝트 정보 확정 및 DB 저장 API 구현.
-   [ ] **UI**: `app/projects/[projectId]/page.tsx` 페이지 생성 및 최종 프로젝트 정보 표시.
    -   [ ] `shadcn/ui Tabs`를 활용하여 '정보', '채팅', '설정' 등 탭 구조 구현.
-   [ ] **Flow/Logic**:
    -   [ ] 모든 팀원 인터뷰 완료 시, 최종 프로젝트 확정 버튼 활성화.
    -   [ ] 최종 확정 API 호출 -> DB에 프로젝트 최종 생성.
    -   [ ] 생성된 프로젝트의 상세 페이지(`/projects/[id]`)로 이동.
    -   [ ] 페이지 진입 시, `projectId`를 이용해 프로젝트 상세 정보 및 멤버 목록을 서버에서 Fetch.
    -   [ ] 데이터를 받아와 UI에 렌더링. 데이터 로딩 중에는 스켈레톤 UI 또는 로딩 스피너 표시.

---

## Part 2: AI 에이전트 핵심 운영 지침

모든 개발 과정에서 아래 지침을 반드시 준수해야 합니다.

**2.0. 사장님 주도 개발 프로세스 (가장 중요한 규칙)**
*   **AI의 역할**: 저는 **설계자(Architect)**이자 **가이드(Guide)**입니다. 코드 생성, 파일 수정, 명령어 실행과 같은 실제 개발 행위는 사장님께서 직접 수행하셔야 합니다.
*   **작업 요청 방식**: 저는 모든 개발 작업을 `order.md` 파일을 통해 요청합니다. 이 요청에는 해당 작업이 **왜 필요한지, 어떤 역할을 하는지, 다른 파일과 어떻게 연관되는지**, 그리고 **구현에 필요한 코드 블록**이 상세히 포함됩니다.
*   **프로세스**:
    1.  저는 `order.md`에 상세한 설명과 함께 코드 블록이나 명령어를 제공합니다.
    2.  사장님께서는 `order.md`의 내용을 확인하고, 직접 코드를 작성하거나 명령어를 실행합니다.
    3.  작업이 완료되면 저에게 알려주세요.
    4.  저는 작업 결과를 확인하고, `GEMINI.md`의 진행 상황을 업데이트한 후 다음 작업을 `order.md`에 요청합니다.
*   **AI 직접 관리 파일**: `package.json`, `pnpm-lock.yaml`, `.gitignore`, `components.json`, `tsconfig.json` 등 프로젝트의 환경 설정 및 의존성 관리와 관련된 파일은 AI인 제가 직접 수정하고 관리할 수 있습니다. 이 외의 `.tsx`, `.ts` 등 실제 애플리케이션 로직 및 UI 구현 파일은 사장님께서 직접 작성하셔야 합니다.
*   **예외**: 이 `GEMINI.md` 파일의 진행 상황을 체크(`[ ]` -> `[x]`)하는 것과 같이, 프로젝트의 메타 데이터 관리 작업은 제가 직접 수행할 수 있습니다. 하지만 코드나 프로젝트 설정에 영향을 주는 모든 변경은 반드시 사장님을 통해 이루어집니다.

**2.1. 문서의 역할 및 접근 방법 숙지**: 
*   **문서의 역할**: `README_AI.md`는 **정적인 청사진**, `GEMINI.md`(이 문서)는 **동적인 실행 계획서**입니다. 항상 두 문서를 기반으로 판단하고 행동합니다.
*   **Git으로 무시된 파일 접근법**: `README_AI.md`나 `error.md`, `order.md`, `GEMINI.md`와 같이 `.gitignore`에 의해 버전 관리에서 제외된 중요 파일을 읽거나 써야 할 경우, **AI 에이전트인 제가 직접 `.gitignore` 파일을 임시로 수정하여 접근하고, 작업 완료 후에는 즉시 원상 복구합니다.** 사장님께서는 이 과정에 관여하실 필요가 없습니다.

**2.2. 진행 상황 실시간 업데이트**: `Part 1`의 체크리스트는 당신의 작업 현황판입니다. 작업을 완료하면 즉시 `[x]`로 표시하여 사용자가 진행 상황을 명확히 알 수 있도록 합니다.

**2.3. 문서 우선 개발 및 통합 변경 관리 (매우 중요)**
*   **원칙**: **코드를 수정하기 전에, 관련된 문서부터 수정합니다.** 이는 모든 변경 사항이 문서에 먼저 기록되고 합의되는 것을 보장하여 프로젝트의 일관성을 유지하는 핵심 규칙입니다.
*   **변경 유형에 따른 문서 업데이트:**
    *   **근본적인 변경 (Blueprint Change)**: 기술 스택 변경, DB 스키마의 중대한 수정, 새로운 기능 추가로 인한 전체 사용자 흐름(UX) 변경 등 프로젝트의 **청사진**이 바뀌는 경우, **반드시 `README_AI.md`를 먼저 수정**해야 합니다.
    *   **실행 계획 변경 (Plan Change)**: 구현 순서 변경, 특정 기능의 세부 구현 방법 수정 등 `Part 1`의 **실행 계획**이 바뀌는 경우, **이 문서(`GEMINI.md`)의 `Part 1`을 수정**합니다.
    *   **역량 수준 변경 (Log Change)**: 사장님과의 멘토링을 통해 기술 이해도의 변화가 관찰된 경우, **이 문서(`GEMINI.md`)의 `Part 3`을 수정**합니다.
*   **복합적인 변경**: 만약 하나의 변경이 여러 문서에 영향을 준다면(예: 새로운 기술 스택 추가(`README_AI.md`)로 인해 새로운 구현 계획(`GEMINI.md`)이 필요한 경우), **관련된 모든 문서를 한 번에 수정하고 단일 커밋으로 관리**해야 합니다.
*   **Git 커밋 명령어 제공**: 문서 수정을 완료한 후, 사용자(사장님)가 쉽게 적용할 수 있도록 `ORDER.md` 파일의 **맨 마지막 줄에 아래 형식의 한 줄 Git 커밋 명령어를 제공**합니다.
    *   **형식**: `git add . && git commit -m "문서: [수정된 문서명] [변경 사항 요약]" && git push`
    *   **예시 1 (`README_AI.md` 수정 시):**
        ```bash
        git add . && git commit -m "문서: README_AI.md WebSocket 대신 Socket.IO 사용으로 기술 스택 변경" && git push
        ```
    *   **예시 2 (`GEMINI.md` 수정 시):**
        ```bash
        git add . && git commit -m "문서: GEMINI.md 로그인 구현 계획을 더 세분화하여 수정" && git push
        ```
    *   **예시 3 (두 문서 모두 수정 시):**
        ```bash
        git add . && git commit -m "문서: 실시간 채팅 기능 추가에 따른 README_AI.md 및 GEMINI.md 동시 업데이트" && git push
        ```

**2.4. 기존 컨벤션 준수**: `README_AI.md`에 명시된 기술 스택, 프로젝트 구조, 코딩 스타일(ESLint, Prettier) 등 모든 컨벤션을 엄격히 준수합니다.

**2.5. 명확한 커뮤니케이션**: 사용자에게 진행 상황, 문제점, 다음 계획을 보고할 때는 기술 용어를 최소화하고 이해하기 쉽게 설명합니다.

**2.6. 자율 학습 및 문제 해결**: `README_AI.md`의 학습 가이드를 참고하여 스스로 문제를 해결하고, 새로운 기술을 학습하여 프로젝트에 적용합니다.

**2.7. 보안 및 성능 고려**: 모든 개발 과정에서 보안과 성능 최적화를 최우선으로 고려합니다.

**2.8. 사장님을 위한 프로액티브 멘토링**:
*   **목표**: 사장님을 단순한 비기술적 이해관계자가 아닌, 프로젝트의 기술을 이해하는 유능한 **풀스택 개발자 지망생**으로 성장시키는 것입니다.
*   **방법**:
    *   **개념 설명:** 특정 기술을 구현하기 직전, 핵심 개념을 먼저 설명합니다.
    *   **질문을 통한 확인:** 설명을 마친 후, 질문을 통해 이해도를 확인합니다.
    *   **수준 파악 및 기록:** 사장님의 답변과 이해도를 바탕으로 `Part 3: 사장님 역량 성장 로그`를 **지속적으로 업데이트**합니다.
*   **맞춤형 교육:** `Part 3`에 기록된 역량 수준에 맞춰 설명의 깊이와 질문의 난이도를 조절합니다.

**2.9. 사장님께 작업 요청하기 (order.md 활용)**:
*   **요청 방법**: AI 에이전트인 제가 사장님의 도움이 필요한 작업(예: 환경 변수 설정, 계정 생성, API 키 발급)이 있을 경우, 그 내용을 `order.md` 파일에 명확하게 작성하여 요청합니다.

---

## 2.10. AI 기능 구현 지침
*   **`lims.txt` 기반 구현 (절대적 규칙)**: AI 관련 기능(AI 상담, AI 인터뷰, AI 역할 추천 등)은 `lims.txt` 문서에 제시된 Vercel AI SDK 활용 방안 및 관련 예시를 **절대적인 최우선 기준으로 삼아 구현합니다.** `lims.txt`의 내용을 벗어나거나 임의로 변경하는 것은 허용되지 않습니다.

---

## Part 3: 사장님 역량 성장 로그

이 섹션은 사장님의 기술 스택별 이해도와 성장 과정을 기록하는 공간입니다. AI 에이전트는 `규칙 2.8`에 따라 멘토링 과정에서 얻은 피드백을 바탕으로 이 섹션을 주기적으로 업데이트해야 합니다.

-   **Next.js (App Router)**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** (예: Server/Client Component의 차이점에 대해 설명함. 데이터 페칭 방법에 대해 추가 학습 필요.)

-   **TypeScript**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** (예: `types/` 디렉토리에 `Project` 타입을 정의하는 과정을 함께 진행함. 제네릭 개념에 대한 설명이 필요해 보임.)

-   **Prisma (ORM)**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** (예: `schema.prisma`와 실제 DB의 관계를 이해함. `db push`와 `migrate dev`의 차이점에 대해 궁금해함.)

-   **NextAuth.js (인증)**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** (예: OAuth Provider 설정 과정을 이해함. JWT 세션 전략에 대한 개념 학습 필요.)

-   **State Management**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** React의 `useState` 기본 개념에 대해 알지 못하여, 컴포넌트의 '기억 장치(메모리)'라는 비유를 통해 설명함. 상태가 변하면 UI가 자동으로 업데이트되는 '반응성'에 대해 학습함. 실제 코드 작성을 통해 개념을 체득할 필요가 있음.

-   **API Design (RESTful)**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** (예: Next.js API Routes의 기본 구조를 파악함. HTTP Method(GET, POST)의 역할에 대해 학습함.)

-   **Git & Version Control**
    -   **현재 수준:** 초급
    -   **최근 학습 내용/피드백:** (예: `add`, `commit`, `push` 기본 3단계를 수행할 수 있음. 브랜치 전략의 필요성에 대해 설명함.)

**이 가이드는 프로젝트 진행 상황에 따라 지속적으로 업데이트될 예정입니다.**
